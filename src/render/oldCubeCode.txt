
//This will get Fixed!!!
// just want to render some cubes for testing!!!
//cube Vertices
    float vertices[] = {
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,

     0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  0.0f, 1.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
};

float vertexSide[] = {
    0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,
    1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,
    2.0f,2.0f,2.0f,2.0f,2.0f,2.0f,
    3.0f,3.0f,3.0f,3.0f,3.0f,3.0f,
    4.0f,4.0f,4.0f,4.0f,4.0f,4.0f,
    5.0f,5.0f,5.0f,5.0f,5.0f,5.0f,
    6.0f,6.0f,6.0f,6.0f,6.0f,6.0f
};

void Renderer::setUpBuffers(){


    // Vertex Array Object
    glGenVertexArrays(1, &VAO);  
    
    glBindVertexArray(VAO);


    glGenBuffers(1, &VBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    
    
    //  Vertex attributes:
    // position attribute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    // texture attribute
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3* sizeof(float)));
    glEnableVertexAttribArray(1);

    glGenBuffers(1, &VBO2);
    glBindBuffer(GL_ARRAY_BUFFER, VBO2);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexSide), vertexSide, GL_STATIC_DRAW);
    // side attribute
    glVertexAttribPointer(2, 1, GL_FLOAT, GL_FALSE, sizeof(float), (void*)(0));
    glEnableVertexAttribArray(2);
}

void Renderer::render(World& world, Camera& camera){
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


    glBindVertexArray(VAO);

    glm::mat4 view;
    view = camera.getViewMatrix();

    unsigned int viewLoc = glGetUniformLocation(shaderprogram.ID, "view");
    glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));

    
    int width, height;
    glfwGetFramebufferSize(window, &width, &height);
    
    glm::mat4 projection;
    projection = glm::perspective(glm::radians(camera.getFov()),  (float)width / (float)height, 0.1f, 100.0f);

    unsigned int projectionLoc = glGetUniformLocation(shaderprogram.ID, "projection");
    glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));

    std::queue<RenderableBlock>  renQ = world.toRenderableQueue();
    //This while loop is hella sketchy. Will change later!!!!
    while(!renQ.empty())
        {
            RenderableBlock ren = renQ.front();
            renQ.pop();

            unsigned int textureSizeLoc = glGetUniformLocation(shaderprogram.ID, "textureSize");
            glUniform2f(textureSizeLoc,(float)16 / (float)atlasWidth,(float)16 / (float)atlasHeight);

            
            glm::vec2 textureOffsets[6] = {jsonGet(jsonAtlasData, ren.sideTexture,atlasWidth,atlasHeight),jsonGet(jsonAtlasData, ren.sideTexture,atlasWidth,atlasHeight),jsonGet(jsonAtlasData, ren.sideTexture,atlasWidth,atlasHeight),jsonGet(jsonAtlasData, ren.sideTexture,atlasWidth,atlasHeight),jsonGet(jsonAtlasData, ren.topTexture,atlasWidth,atlasHeight),jsonGet(jsonAtlasData, ren.botTexture,atlasWidth,atlasHeight)};

            unsigned int offsetLoc = glGetUniformLocation(shaderprogram.ID, "textureOffset");
            glUniform2fv(offsetLoc, 6, glm::value_ptr(textureOffsets[0]));

            glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, glm::vec3(ren.x,ren.y,ren.z) );
            shaderprogram.setMat4("model", model);
            
            glDrawArrays(GL_TRIANGLES, 0, 36);
        }

    glfwSwapBuffers(window);

}




// Shader Programs:

// shader.vs:
#version 330 core
layout (location = 0) in vec3 aPos;   // the position variable has attribute position 0
layout (location = 1) in vec2 aTexCoord;
layout (location = 2) in float sideIndex;
  
out vec2 TexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform vec2 textureOffset[6];
uniform vec2 textureSize;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord =    aTexCoord*textureSize + textureOffset[int(sideIndex)]; 
}   



// shader.fs
#version 330 core
out vec4 FragColor;  

in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D textureAtlas;
  
void main()
{
    FragColor = texture(textureAtlas,TexCoord);
}